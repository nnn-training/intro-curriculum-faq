{"pageProps":{"post":{"title":"Docker 関連のトラブル","content":"<h1>Docker 関連のトラブル</h1>\n<hr>\n<p><strong>目次</strong></p>\n<ul>\n<li><a href=\"#1\">(1) Docker Desktop がインストールできない</a></li>\n<li><a href=\"#2\">(2) docker compose up -d（コンテナ起動）で失敗する</a></li>\n<li><a href=\"#3\">(3) (winpty) docker compose exec app bash で失敗する</a></li>\n<li><a href=\"#4\">(4) PostgreSQL のバージョンを上げるとデータベースのコンテナの起動に失敗する</a></li>\n<li><a href=\"#5\">(5) npx prisma で失敗する。または Intel MacBook にて Docker を利用していると Segmentation fault と表示される。</a></li>\n<li><a href=\"#6\">(6) <code>yarn add prisma@4.11.0</code> で失敗する</a></li>\n<li><a href=\"#7\">(7) M シリーズ Mac にて Docker コンテナ立ち上げ時に警告が出る</a></li>\n</ul>\n<hr>\n<h2>(1) Docker Desktop がインストールできない <a id=\"1\"></a></h2>\n<h3>問題詳細</h3>\n<p>コンピュータの記憶容量の残りが十分あるにもかかわらず、Docker Desktop がインストールできない場合があります。</p>\n<h3>原因</h3>\n<p>OS が Docker が対応していない古いバージョンであることが原因です。\nDocker が対応している OS のバージョンは、次の通りです（2021.7.12 最終確認）。</p>\n<ul>\n<li>macOS（Intel の CPU を搭載する端末）：<strong>バージョン 10.14（Mojave）以降</strong></li>\n<li>macOS（Apple silicon を搭載する端末）：<strong>Rosetta 2 がインストールされていること</strong>\n<ul>\n<li>以上 2 つは、<a href=\"https://docs.docker.com/docker-for-mac/install/#system-requirements\">Docker のヘルプページ</a>の内容に基づきます。</li>\n</ul>\n</li>\n<li>Windows：Windows 10（詳細なバージョンは <a href=\"https://docs.docker.com/docker-for-windows/install/#system-requirements\">Docker のヘルプページ</a>を参照してください。Windows の Edition（例えば Windows 10 Home や Windows 10 Pro など）によってバージョンが異なります。）</li>\n</ul>\n<h3>→ 解決方法</h3>\n<p>OS のアップデートを試してください。</p>\n<ul>\n<li>macOS をお使いの方は、<a href=\"https://support.apple.com/ja-jp/HT201541\">Apple のサポートページ</a>を参照してください。</li>\n<li>Windows をお使いの方は、<a href=\"https://support.microsoft.com/ja-jp/windows/windows-10-%E3%82%92%E6%9B%B4%E6%96%B0%E3%81%99%E3%82%8B-3c5ae7fc-9fb6-9af1-1984-b5e0412c556a\">Microsoft のサポートページ</a>を参照してください。</li>\n</ul>\n<p>なお、今後も OS のバージョンが古くなると、Docker が動かなくなる可能性があります。OS はこまめにアップデートすると良いでしょう。</p>\n<br>\n<h2>(2) <code>docker compose up -d</code> （コンテナ起動）で失敗する<a id=\"2\"></a></h2>\n<h3>問題詳細</h3>\n<p>Docker Desktop のインストールには成功したものの、コンテナ起動に失敗する場合があります。<br>\n複数の原因が考えられます。</p>\n<ul>\n<li><a href=\"#2-1\">・原因1（Windows、Mac）</a></li>\n<li><a href=\"#2-2\">・原因2（Windows、Mac）</a></li>\n<li><a href=\"#2-3\">・原因3（Windows、Mac）</a></li>\n<li><a href=\"#2-4\">・原因4（Windows のみ）</a></li>\n</ul>\n<h3>原因1（Windows、Mac）<a id=\"2-1\"></a></h3>\n<p>そもそも Docker Desktop が起動していない場合 <code>docker</code> コマンドを使用することはできません。<br>\nデフォルトでは Docker Desktop は PC 起動時に同時に立ち上がる設定になっていることが多いのですが、PC の状態により起動していないケースもあります。</p>\n<p>Docker Desktop が起動している場合、タスクバー（Windows）やメニューバー（Mac）にクジラのアイコンが <strong>止まって</strong> 表示されます。\nなお、クジラのアイコンが動いているのは起動中という意味です。</p>\n<p>また、コマンドラインからも Docker Desktop のステータスを確認できます。</p>\n<pre><code>docker version\n</code></pre>\n<p>というコマンドを入力した際に</p>\n<pre><code>Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?\n</code></pre>\n<p>や</p>\n<pre><code>Error response from daemon: dial unix docker.raw.sock: connect: connection refused\n</code></pre>\n<p>というメッセージが表示されなければ、正しく起動できているはずです。</p>\n<h3>→ 原因1の解決方法</h3>\n<p>アプリケーション一覧から Docker のアイコンをクリックします。<br>\nDocker Desktop が起動した後、<code>docker</code> コマンドが使えるか確認してみてください。</p>\n<p>また、Docker が自動起動していない場合は、下記の手順で自動起動の設定ができます。</p>\n<p>まず、Docker Desktop の歯車アイコン(Settings)をクリックします。</p>\n<p><img src=\"/faq/images/intro/docker-settings-01.png\" alt=\"DockerDesktopの設定を開く\"></p>\n<p>「Settings」の画面が開いたら、<br>\n「Start Docker Desktop when you log in」をチェックし、<br>\n「Open Docker Dashboard at startup」のチェックを外します。<br>\nそして、「Apply &#x26; Restart」をクリックしてください。</p>\n<p><img src=\"/faq/images/intro/docker-settings-02.png\" alt=\"設定を変更する\"></p>\n<p>設定が終ったら、 PC を再起動した後にも <code>docker</code> コマンドが使えるか確認してみてください。</p>\n<br>\n<h3>原因2（Windows、Mac）<a id=\"2-2\"></a></h3>\n<p>他の起動中の Docker コンテナと衝突して、新しくコンテナが起動できないことがあります。</p>\n<p>例えば、次のようなエラーが表示されます。</p>\n<pre><code>Starting sample_app_1 ... error\n\nERROR: for sample_app_1  Cannot start service app: driver failed programming external connectivity on endpoint sample_app_1 (5xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx0): Bind for 0.0.0.0:8000 failed: port is already allocated\n\n...\n</code></pre>\n<h3>→ 原因2の解決方法</h3>\n<p>どのディレクトリのコンテナが衝突しているかわかる場合は、当該ディレクトリに移動してコンテナを終了・破棄します。</p>\n<pre><code>docker compose down\n</code></pre>\n<p>わからない場合は、次のように<strong>全てのコンテナを終了・破棄</strong>します（コンテナは原則破棄するものなので、特に悪影響はありません）。</p>\n<pre><code>docker stop $(docker ps -aq)\ndocker rm $(docker ps -aq)\n</code></pre>\n<p>再度起動したいコンテナのディレクトリに移動して、<code>docker compose up -d</code> を試してみてください。</p>\n<br>\n<h3>原因3（Windows、Mac）<a id=\"2-3\"></a></h3>\n<p>Docker Desktop が正常に起動していない場合、次のように表示される場合があります。</p>\n<pre><code>Traceback (most recent call last):\n  File \"urllib3/connectionpool.py\", line 670, in urlopen\n  File \"urllib3/connectionpool.py\", line 392, in _make_request\n  File \"http/client.py\", line 1255, in request\n  File \"http/client.py\", line 1301, in _send_request\n  File \"http/client.py\", line 1250, in endheaders\n...\n</code></pre>\n<h3>→ 原因3の解決方法</h3>\n<p>Docker Desktop を再起動してみてください。</p>\n<br>\n<h3>原因4（Windows ユーザー向け）<a id=\"2-4\"></a></h3>\n<p>やや特殊ですが、過去に Docker Desktop ではなく <a href=\"https://docs.docker.jp/toolbox/overview.html\">Docker Toolbox</a> を使って Docker を使用した経験のある方は、その際の設定が誤って読み込まれてしまうことがあります。</p>\n<p>具体的には、以下のような環境変数が Docker Toolbox によって設定されてしまうことが問題になります。</p>\n<pre><code>DOCKER_HOST\nDOCKER_CERT_PATH\nDOCKER_TLS_VERIFY\nDOCKER_MACHINE_NAME\n</code></pre>\n<h3>→ 原因4の解決方法</h3>\n<p><code>DOCKER_</code> で始まる環境変数を一括して削除します。</p>\n<p>管理者権限で PowerShell を起動し、</p>\n<pre><code>Remove-Item Env:DOCKER_*\n</code></pre>\n<p>と入力してください。</p>\n<h2>(3) <code>(winpty) docker compose exec app bash</code> で失敗する <a id=\"3\"></a></h2>\n<h3>表記について</h3>\n<p>ここでは、表記を簡単にするため、<strong>Windows でのコマンドと Mac でのコマンドをまとめて「<code>(winpty) docker compose exec app bash</code>」と書きます</strong>。そのため、Windows の場合は「<code>winpty docker compose exec app bash</code>」に、Mac の場合は「<code>docker compose exec app bash</code>」に、それぞれ読み替えてください。</p>\n<h3>問題詳細</h3>\n<p><code>docker compose up -d</code>（コンテナ起動）には成功したものの、<code>(winpty) docker compose exec app bash</code> でコンテナに入れない場合があります。</p>\n<h3>原因</h3>\n<p>Dockerfile を一度変更したことがあるにもかかわらず、<code>docker compose build</code> でイメージをビルドし直していない可能性があります。</p>\n<h3>→解決方法</h3>\n<p><code>docker compose up build</code> 実行した後に、<code>docker compose up -d</code>（コンテナ起動） を実行し、 <code>(winpty) docker compose exec app bash</code> を実行してみてください。</p>\n<h2>(4) PostgreSQL のバージョンを上げるとデータベースのコンテナの起動に失敗する <a id=\"4\"></a></h2>\n<h3>表記について</h3>\n<p>ここでは、表記を簡単にするため、<strong>Windows でのコマンドと Mac でのコマンドをまとめて「<code>(winpty) docker compose exec app bash</code>」と書きます</strong>。そのため、Windows の場合は「<code>winpty docker compose exec app bash</code>」に、Mac の場合は「<code>docker compose exec app bash</code>」に、それぞれ読み替えてください。</p>\n<p>また、PostgreSQL のコンテナを「db コンテナ」と呼ぶことにします。</p>\n<h3>問題詳細</h3>\n<p>db コンテナにアクセスする際や、db コンテナにアクセスするソフトウェアを使用する際にエラーが発生することがあります。例えば Sequalize を使用している場合は SequelizeHostNotFoundError が発生します。</p>\n<h3>原因</h3>\n<p>db コンテナが参照しているデータベースファイルのバージョンが古く、db コンテナの起動に失敗している可能性があります。</p>\n<p>docker compose を使用している場合は、<code>docker compose logs</code> でコンテナのログを確認することができます。おそらく</p>\n<pre><code>Attaching to schedule-arranger_app_1, schedule-arranger_db_1\napp_1  | Welcome to Node.js v14.15.4.\napp_1  | Type \".help\" for more information.\ndb_1   |\ndb_1   | PostgreSQL Database directory appears to contain a database; Skipping initialization\ndb_1   |\ndb_1   | 20XX-XX-XX XX:XX:XX.XXX JST [1] FATAL:  データベースファイルがサーバと互換性がありません\ndb_1   | 20XX-XX-XX XX:XX:XX.XXX JST [1] 詳細:  データディレクトリはPostgreSQLバージョン12で初期化されましたが、これはバージョン14.2 (Debian 14.2-1.pgdg110+1)とは互換性がありません\n</code></pre>\n<p>または</p>\n<pre><code>db_1   | 20XX-XX-XX XX:XX:XX.XXX JST [1] FATAL:  database files are incompatible with server\ndb_1   | 20XX-XX-XX XX:XX:XX.XXX JST [1] DETAIL:  The data directory was initialized by PostgreSQL version 12, which is not compatible with this version 14.2 (Debian 14.2-1.pgdg110+1).\n</code></pre>\n<p>のように表示され、データベースファイルのバージョンが古いことが原因であると分かります。</p>\n<h3>→解決方法</h3>\n<p>解決方法としては</p>\n<ul>\n<li>データベースを作り直す</li>\n<li>データベースを消さず、新しいバージョンの PostgreSQL 用にデータベースをアップグレードする</li>\n</ul>\n<p>などが考えられます。<br>\n前者は簡単ではありますが、<strong>データベースの中身が失われてしまう</strong>ことに注意してください。</p>\n<p>データベースの中身を失いたくない場合や、<strong>Web サービスとして公開した場合</strong>はデータベースのアップグレードをするようにしてください。</p>\n<table>\n  <thead>\n    <tr>\n      <th rowspan=\"2\"></td>\n      <th colspan=\"2\">\n        docker volume コマンドで作成したボリュームを使っている\n      </td>\n    </tr>\n    <tr>\n      <th>はい</td>\n      <th>いいえ</td>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>データベースを作り直したい</th>\n      <td><a href=\"#4-1-2\">方法1-2</a></td>\n      <td><a href=\"#4-1-1\">方法1-1</a></td>\n    </tr>\n    <tr>\n      <th>データベースをアップグレードしたい</th>\n      <td><a href=\"#4-2\">方法2</a></td>\n      <td><a href=\"#4-2\">方法2</a> (★以外)</td>\n    </tr>\n  </tbody>\n</table>\n<h4>方法1-1: データベースを作り直す <a id=\"4-1-1\"></a></h4>\n<p>データベースファイルのあるディレクトリを空にしてください。次回のコンテナ立ち上げ時に再び必要なファイルが作り直され、互換性の問題は解決するはずです。</p>\n<h4>方法1-2: データベースを作り直す (docker volume コマンドを使っている場合) <a id=\"4-1-2\"></a></h4>\n<p><strong>docker volume コマンドにより作成したボリュームにデータベースファイルを設置している場合は</strong>以下のようにして volume を作り直してください。</p>\n<p>まず、</p>\n<pre><code>docker compose down\n</code></pre>\n<p>でコンテナを閉じます。次に</p>\n<pre><code>docker volume rm [データベースファイルのあるvolume名]\ndocker volume create --name=[データベースファイルのあるvolume名]\n</code></pre>\n<p>でデータベース用の volume を作り直します。<code>[データベースファイルのあるvolume名]</code> は例えば <code>my-application-data</code> など、現在使っているデータベース用 volume の名前で読み替えてください。\n1行目では volume の削除を、2行目では volume の作成をしています。</p>\n<p>Volume を作り直す、またはデータベースファイルのあるディレクトリを空にしたら</p>\n<pre><code>docker compose up -d\n(winpty) docker compose exec app bash\n</code></pre>\n<p>と入力し app コンテナに再び入ります。\nコンテナに入れたら、エラーが発生したソフトウェアを再度実行してみましょう。\n実行時にエラーが起こらなければ成功です。</p>\n<h4>方法2: データベースをアップグレードする <a id=\"4-2\"></a></h4>\n<hr>\n<p>注) 方法 2 内で用いられる「★」は <code>docker volume</code> コマンドにより作成したボリュームをデータベース用ボリュームとして用いている方向けの解説です。それ以外の方は読み飛ばして構いません。</p>\n<hr>\n<p>ここでは例として、<code>docker volume</code> で作成したボリューム内のデータベースファイルを PostgreSQL 12 対応のものから 14 対応のものへアップグレードする方法を紹介します。docker volume コマンドにより作成したボリュームを使用していない場合も以下と同様に dump の出力と読み込みをすることで移行できます。</p>\n<p>まず、データベースの Dockerfile を</p>\n<pre><code>FROM postgres:12\n</code></pre>\n<p>など、<strong>現在のデータベースファイルと互換性のあるバージョン</strong>に書き換えます。</p>\n<p>次に</p>\n<pre><code>docker compose up --build -d \n</code></pre>\n<p>でコンテナを立ち上げます。Dockerfile を書き換えたので <code>--build</code> オプションをつけてビルドしています。</p>\n<p>立ち上げたら、次のコマンドで <strong>dump</strong> を出力してください。ここでの dump とは、データベースの中身を SQL コマンドを含んだスクリプトで表したもののことを言います。dump ファイル内のスクリプトを実行することで、現在のデータベースの情報を復元することができます。</p>\n<pre><code>docker compose exec db pg_dumpall --clean --no-role-passwords -U postgres > db.out\n</code></pre>\n<p>このコマンドを実行することで、現在のディレクトリにデータベースの dump である db.out が生成されます。コマンドの実行に失敗した場合は、PostgreSQL のバージョンが volume 内のデータベースファイルと互換性のないものである可能性があります。</p>\n<details>\n<summary>コマンドの説明 (クリックで展開)</summary>\n<hr>\n<pre><code>docker compose exec &#x3C;service> &#x3C;command>\n</code></pre>\n<p>は <code>&#x3C;service></code> コンテナに入り、<code>&#x3C;command></code> コマンドを実行するコマンドです。ここでは db コンテナに入り、<code>pg_dumpall</code> コマンドを実行しています。</p>\n<pre><code>pg_dumpall --clean --no-role-passwords -U postgres\n</code></pre>\n<p>はデータベースの dump を出力する PostgreSQL のコマンドです。</p>\n<p><code>--clean</code> は移行先にデータベースが存在した場合も DROP して作り直すオプションです。</p>\n<p><code>--no-role-password</code> はロールのパスワードを出力しないオプションです。現在使用しているソフトウェアでデータベースのパスワード認証を利用していない場合は、このオプションが必要になります。</p>\n<p><code>-U</code> は dump するユーザを指定するオプションです。ここではユーザ <code>postgres</code> を指定しています。</p>\n<p>最後に <code>> db.out</code> で現在のディレクトリに <code>pg_dumpall</code> の出力を db.out として保存します。</p>\n<hr>\n</details>\n<p>次にデータベースのバージョンを上げるため、一度コンテナを閉じます。</p>\n<pre><code>docker compose down\n</code></pre>\n<p>db コンテナに使う Dockerfile の FROM の部分を</p>\n<pre><code>FROM postgres:14.2\n</code></pre>\n<p>など移行先のバージョンに書き換えます。</p>\n<h5>volume のバックアップ (★ docker volume コマンドを使っている場合)</h5>\n<p>今 volume 内には古いデータベースが残っているため、このままコンテナを立ち上げると db コンテナの立ち上げに失敗してしまいます。そこで、volume を一度丸ごと削除して作り直します。</p>\n<p>その前に、念のために <strong>volume のバックアップ</strong>を取っておきます。次のコマンドでバックアップ用の volume を作ります。ここではバックアップ用の volume 名を database-backup としています。</p>\n<pre><code>docker volume create --name=database-backup\n</code></pre>\n<p>次に元のデータベース volume (ここでは my-application-data とします) の中身をバックアップ volume にコピーします。</p>\n<p>Docker には volume をコピーするコマンドがないので、次のように<strong>新たにコンテナを作ることにより</strong>コピーします。(volume のリネームもできないため、リネームしたい場合もこの手順を踏む必要があります)</p>\n<p>次のコマンドを実行してください。</p>\n<pre><code>docker run --rm -v my-application-data:/from -v database-backup:/to alpine cp -a /from/. /to\n</code></pre>\n<p>これを実行することで、my-application-data の中身が database-backup にコピーされます。</p>\n<details>\n<summary>コマンドの説明 (クリックで展開)</summary>\n<hr>\n<pre><code>docker run [options] &#x3C;image> [command]\n</code></pre>\n<p>は指定した Docker イメージ <code>&#x3C;image></code> からコンテナを作り起動するコマンドです。<code>[options]</code> にはオプション、<code>[command]</code> にはコンテナ立ち上げ後にコンテナ内で実行するコマンドを指定します。</p>\n<p><code>--rm</code> はコンテナ終了後にコンテナを削除するオプションです。</p>\n<p>2つの <code>-v</code> オプションでは、</p>\n<ul>\n<li>コピー元の my-application-data をコンテナ内の <code>/from</code> にマウントすること</li>\n<li>コピー先の database-backup を <code>/to</code> にマウントすること</li>\n</ul>\n<p>を指示しています。</p>\n<p><a href=\"https://hub.docker.com/_/alpine\">alpine</a> は軽量な Linux ディストリビューションである Alpine Linux の Docker イメージです。今回はファイルコピーという単純な作業のみをするので alpine を指定しています。そして <code>[command]</code> として</p>\n<pre><code>cp -a /from/. /to\n</code></pre>\n<p>を指定しています。コンテナ実行後、上記コマンドにより <code>/from</code> の中身は <code>/to</code> にコピーされます。<code>/from</code> と <code>/to</code> はそれぞれ my-application-data と database-backup が対応するので、これで volume のコピーができたことになります。</p>\n<hr>\n</details>\n<p>念のため、database-backup volume にデータがコピーされたかどうか確認してみましょう。</p>\n<pre><code>docker run --rm -v database-backup:/volume alpine ls /volume\n</code></pre>\n<p>以上のコマンドでバックアップ volume の中身を確認することができます。うまくコピーされていれば成功です。</p>\n<h4>volume の消去とデータベースの読み込み</h4>\n<p>さて、volume のバックアップが取れたので元の volume を作り直します。\n次のコマンドを実行してください(★)。</p>\n<pre><code>docker volume rm my-application-data\ndocker volume create --name=my-application-data\n</code></pre>\n<p><code>docker volume</code> によるボリュームを<strong>用いていない</strong>場合は適切なディレクトリの中身を削除してください。この際、ディレクトリのバックアップを忘れないようにしましょう。\n例えば <code>~/workspace/db/</code> にデータベースがあった場合、次のようにしてバックアップとディレクトリの中身の削除ができます。</p>\n<pre><code>cd ~/workspace\n\n# db を db-backup にリネーム\nmv db db-backup \n\n# db フォルダを作り直す\nmkdir db\n</code></pre>\n<p>volume を作りなおせたらコンテナを立ち上げます。また、先ほど Dockerfile を書き換えたのでビルドも忘れずにしましょう。</p>\n<pre><code>docker compose up --build -d\n</code></pre>\n<p>次に、データベースを新しいバージョンの PostgreSQL に読み込みます。次のコマンドを実行してください。</p>\n<pre><code>cat db.out | docker compose exec -T db psql -f - -U postgres\n</code></pre>\n<details>\n<summary>コマンドの説明 (クリックで展開)</summary>\n<hr>\n<p><code>cat db.out</code> で db.out の中身を標準出力します。これをパイプ (<code>|</code>) で <code>docker compose</code> コマンドに渡します。\n<code>docker compose exec</code> の <code>-T</code> は標準入力を受け取るために必要なオプションです。</p>\n<p>db コンテナ内で実行する <code>psql</code> コマンドは PostgreSQL を実行するコマンドです。<code>-f</code> オプションは読み込むファイルを指定するオプションです。指定したファイル名が <code>-</code> であるとき、標準入力を受け取ります。また、<code>-U</code> オプションでは読み込むときに使用するユーザ名を指定します。</p>\n<hr>\n</details>\n<p>これで読み込みが成功しているはずです。</p>\n<h5>実行確認</h5>\n<p>最後に実際にデータベースが移行できているか確認してみましょう。エラーが発生していたソフトウェアを再度実行してください。これでエラーが出ず、無事に起動できれば成功です。</p>\n<p>パスワード認証エラー等が出た場合は dump 時に <code>--no-role-password</code> オプションを指定していたかを確認してみてください。</p>\n<h5>移行に失敗した場合は</h5>\n<p>移行に失敗した場合は次の手順でもとに戻すことができます。</p>\n<h6>★ docker volume コマンドを使っている場合</h6>\n<p>まず <code>docker compose down</code> でコンテナを閉じてから</p>\n<pre><code># my-application-data を消去して作り直す\ndocker volume rm my-application-data\ndocker volume create --name=my-application-data\n\n# バックアップから復元\ndocker run --rm -v database-backup:/from -v my-application-data:/to alpine cp -a /from/. /to\n</code></pre>\n<p>を実行します。これで my-application-data には古いバージョンのデータベースが復元されました。</p>\n<h6>docker volume コマンドを使っていない場合</h6>\n<p>元のデータベースをバックアップを、データベースを置いていたディレクトリに戻します。データベースの存在するディレクトリが <code>~/workspace/db/</code> 、バックアップが <code>~/workspace/db-backup/</code> にある場合は次のようにしてバックアップを復元できます。</p>\n<pre><code>cd ~/workspace\n\n# db を削除\nrm -rf db\n\n# db-backup を db にリネーム\nmv db-backup db\n</code></pre>\n<h5>移行に成功した場合の後片付け</h5>\n<p>移行に成功したと判断できたら、以下のコマンドを実行することで</p>\n<ul>\n<li>バックアップ用 volume (★)</li>\n<li>データベースの dump</li>\n</ul>\n<p>を削除することができます。</p>\n<pre><code>docker volume rm database-backup\nrm db.out\n</code></pre>\n<h2>(5) npx prisma で失敗する。または Intel MacBook にて Docker を利用していると Segmentation fault と表示される。 <a id=\"5\"></a></h2>\n<h3>問題詳細</h3>\n<p>コンテナのコンソール上で、 <code>npx prisma init</code> といった <code>npx prisma</code> から始まるコマンドを実行すると、 <code>Segmentation fault</code> と表示されて動作しない。</p>\n<p>または、Intel MacBook において、 Docker を利用していると、 <code>Segmentation fault</code> というエラーが表示される場合がある。</p>\n<h3>原因</h3>\n<p>Intel 製のチップを搭載した MacBook において、 Virtualization Framework というものが有効になっている際に起こる不具合です。\nこれは、 Docker Desktop v19.0.0 以上で発生が確認されています。</p>\n<p>下記のサイトでこちらの不具合は把握されています。</p>\n<p><a href=\"https://github.com/docker/for-mac/issues/6824\">Docker Desktop for mac での issue</a></p>\n<h3>→解決方法</h3>\n<p>ファイル共有システムに利用している VirtioFS が Virtualization Framework を利用しています。<br>\nですから、ファイル共有システムを他のものへと変更することで、原因である Virtualization Framework を無効化する必要があります。</p>\n<p>そのために、Docker Desktop の設定を変更します。</p>\n<p>まず、 Docker Desktop を開いてください。</p>\n<p>開いたら、画像で示した右上にある、歯車マークをクリックしてください。</p>\n<p><img src=\"/faq/images/intro/how-to-set-grpc-1.png\" alt=\"Docker Desktop のホーム画面\"></p>\n<p>クリックすると、以下のような設定画面が表示されます。</p>\n<p>下の方へスクロールすると、画像で示したように、「Choose file sharing implementation for your containers」 と書かれた部分があります。</p>\n<p><img src=\"/faq/images/intro/how-to-set-grpc-2.png\" alt=\"Docker Desktop の設定画面\"></p>\n<p>これを以下の画像の指示に沿って、「gRPC FUSE」に変更してください。</p>\n<p><img src=\"/faq/images/intro/how-to-set-grpc-3.png\" alt=\"ファイル共有システムを gRPC FUSE に変更\"></p>\n<p>すると、上の「Use Virtualization framework」 と書かれた部分のチェックを変更できるようになります。<br>\nこのチェックを外すことで、「Virtualization framework」を無効化できます。</p>\n<p>以下の画像を参考に、このチェックを外し、右下の「Apply &#x26; restart」 をクリックしてください。</p>\n<p><img src=\"/faq/images/intro/how-to-set-grpc-4.png\" alt=\"Virtualization framework を無効化\"></p>\n<p>これによって Virtualization Framework を無効化でき、エラーが解消されるはずです。</p>\n<p>なお、以前より Docker を利用した際の挙動が重くなる可能性があります。</p>\n<h2>(6) <code>yarn add prisma@4.11.0</code> で失敗する<a id=\"6\"></a></h2>\n<h3>問題詳細</h3>\n<p>Apple Silicon を搭載した M シリーズ MacBook において、 Docker コンテナ内で <code>yarn add prisma@4.11.0</code> を実行すると、以下のようなエラーが表示される場合があります。</p>\n<pre><code class=\"language-sh\">qemu: uncaught target signal 11 (Segmentation fault) - core dumped\nSegmentation fault\n</code></pre>\n<p>この場合、 Docker Desktop の設定を変更することで解決が望めます。</p>\n<h3>→解決方法</h3>\n<p>Rosetta という機能を有効にするために、Docker Desktop の設定を変更します。</p>\n<p>以下のスクリーンショットで示された右上赤枠内の歯車アイコンをクリックしてください。</p>\n<p><img src=\"/faq/images/intro/docker-enable-rosetta-01.png\" alt=\"\"></p>\n<p>次に、Use Rosetta for x86/amd64 emulation on Apple Silicon と書かれたチェックボックスにチェックを入れ、Rosetta を有効化してください。</p>\n<p><img src=\"/faq/images/intro/docker-enable-rosetta-02.png\" alt=\"\"></p>\n<p>チェックボックスにチェックを入れたら、右下の「Apply &#x26; Restart」と書かれたボタンをクリックして、 Docker Desktop を再起動してください。</p>\n<p><img src=\"/faq/images/intro/docker-enable-rosetta-03.png\" alt=\"\"></p>\n<p>これで Rosetta が有効になり、エラーが解消されるはずです。</p>\n<p>再起動後、 Docker コンテナを <code>docker compose up -d --build</code> コマンドで立ち上げてエラーが解消されたか確認してみてください。</p>\n<h3>原因</h3>\n<p>これは、 Docker イメージが想定するアーキテクチャと実際のコンピュータのアーキテクチャの違いによって起きるエラーです。</p>\n<p>教材では、 <code>Dockerfile</code> の 1 行目に <code>--platform=linux/x86_64</code> と書かれています。</p>\n<p>これが Docker イメージの OS とアーキテクチャを指定するための記述です。</p>\n<p><a href=\"https://hub.docker.com/_/node/tags\">Docker Hub の Node イメージのタグ一覧</a>を見ると、<code>OS/ARCH</code> という部分があるかと思います。<br>\n実は Docker イメージは OS とアーキテクチャの組み合わせによって分けられており、この部分がそれを示しています。</p>\n<p><img src=\"/faq/images/intro/docker-os-arch.png\" alt=\"\"></p>\n<p><code>x86_64</code> というのは Intel CPU 用のアーキテクチャで、 <code>AMD64</code> とも言われるものです。一方で、M シリーズ Mac の CPU は ARM アーキテクチャを採用しています。<br>\nつまり、<code>--platform=linux/x86_64</code> を指定すると、ARM アーキテクチャで動く CPU 上で AMD64 アーキテクチャを動かさなければなりません。</p>\n<p>このための仕組みとしてエミュレータが用意されており、Docker イメージの対応するアーキテクチャと実際のコンピュータのアーキテクチャの差異を吸収してくれるようになっています。</p>\n<p>そして今回のエラーは、使っているエミュレータがうまく動作していないことが原因です。</p>\n<p>ですので、エミュレータを Rosetta というものに切り替えることで解消します。</p>\n<h2>(7) M シリーズ Mac にて Docker コンテナ立ち上げ時に警告が出る<a id=\"7\"></a></h2>\n<h3>問題詳細</h3>\n<p>M シリーズ Mac にて Docker コンテナ立ち上げ時に以下のような警告が出る場合があります。</p>\n<pre><code class=\"language-sh\">app The requested image's platform (linux/amd64) does not match the detected host platform (linux/arm64/v8) and no specific platform was requested\n</code></pre>\n<h3>→解決方法</h3>\n<p>これは致命的なエラーではないので、教材の進行に問題はありませんので無視しても大丈夫です。</p>\n<p>教材で提示された <code>Dockerfile</code> の 1 行目にある <code>--platform=linux/x86_64</code> を削除し、 <code>docker compose up -d --build</code> コマンドを実行すれば解決するはずです。</p>\n<h3>原因</h3>\n<p>これは <a href=\"#6\">(6) <code>yarn add prisma@4.11.0</code> で失敗する</a>と同じことが原因です。</p>\n<p>使っているパソコンのアーキテクチャが Docker イメージが想定するものと異なるため、パフォーマンスが低下する可能性があり、それを警告として表示しているものです。</p>\n<p>M シリーズ Mac が搭載している Apple Silicon は CPU のアーキテクチャが ARM アーキテクチャですので、それに対応したイメージを使った方がパフォーマンスが向上します。</p>\n<p><code>--platform=linux/x86_64</code> という記述をなくすと、自動的に Apple Silicon に対応したイメージを使ってくれるようになります。</p>\n"}},"__N_SSG":true}