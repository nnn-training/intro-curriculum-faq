<!DOCTYPE html><html><head><title>FAQ・トラブルシューティング - N予備校プログラミングコース</title><meta charSet="utf-8"/><meta name="viewport" content="initial-scale=1.0, width=device-width"/><meta name="next-head-count" content="3"/><link rel="preload" href="/faq/_next/static/css/fb829427aad2089c.css" as="style" crossorigin=""/><link rel="stylesheet" href="/faq/_next/static/css/fb829427aad2089c.css" crossorigin="" data-n-g=""/><link rel="preload" href="/faq/_next/static/css/1743fd1c3dc99af4.css" as="style" crossorigin=""/><link rel="stylesheet" href="/faq/_next/static/css/1743fd1c3dc99af4.css" crossorigin="" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/faq/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/faq/_next/static/chunks/webpack-0aa5015d31873247.js" defer="" crossorigin=""></script><script src="/faq/_next/static/chunks/framework-0c7baedefba6b077.js" defer="" crossorigin=""></script><script src="/faq/_next/static/chunks/main-d765e8235e43fbb6.js" defer="" crossorigin=""></script><script src="/faq/_next/static/chunks/pages/_app-5b682cfa57837f7e.js" defer="" crossorigin=""></script><script src="/faq/_next/static/chunks/961-608d7e5dc7e4f44d.js" defer="" crossorigin=""></script><script src="/faq/_next/static/chunks/651-37e24e41736555c4.js" defer="" crossorigin=""></script><script src="/faq/_next/static/chunks/pages/%5B...slug%5D-4c18164805db503d.js" defer="" crossorigin=""></script><script src="/faq/_next/static/F3Ge2EVgkAzlU4r2fKG0E/_buildManifest.js" defer="" crossorigin=""></script><script src="/faq/_next/static/F3Ge2EVgkAzlU4r2fKG0E/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><div><header class="px-5 "><div class="max-w-4xl mx-auto pt-5 pb-2 border-gray-100 border-b"><a href="/faq/"><div class="flex items-center"><div class="icon ml-1 mb-0.5 cursor-pointer"><img src="/faq/images/nyobiko.png" width="100" height="100"/></div><h1 class="leading-4 pl-4 cursor-pointer"><div class="ml-1">N予備校プログラミングコース</div><div class="font-bold text-xl ml-1">FAQ・トラブルシューティング</div></h1></div></a></div></header><main class="px-5 bg-blue-50 pt-5 pb-20 min-h-screen"><div class="max-w-4xl mx-auto bg-white rounded-2xl px-4 pb-20"><div class="markdown-body"><h1>Docker 関連のトラブル</h1>
<hr>
<p><strong>目次</strong></p>
<ul>
<li><a href="#1">(1) Docker Desktop がインストールできない</a></li>
<li><a href="#2">(2) docker compose up -d（コンテナ起動）で失敗する</a></li>
<li><a href="#3">(3) (winpty) docker compose exec app bash で失敗する</a></li>
<li><a href="#4">(4) PostgreSQL のバージョンを上げるとデータベースのコンテナの起動に失敗する</a></li>
<li><a href="#5">(5) npx prisma で失敗する。または Intel MacBook にて Docker を利用していると Segmentation fault と表示される。</a></li>
</ul>
<hr>
<h2>(1) Docker Desktop がインストールできない <a id="1"></a></h2>
<h3>問題詳細</h3>
<p>コンピュータの記憶容量の残りが十分あるにもかかわらず、Docker Desktop がインストールできない場合があります。</p>
<h3>原因</h3>
<p>OS が Docker が対応していない古いバージョンであることが原因です。
Docker が対応している OS のバージョンは、次の通りです（2021.7.12 最終確認）。</p>
<ul>
<li>macOS（Intel の CPU を搭載する端末）：<strong>バージョン 10.14（Mojave）以降</strong></li>
<li>macOS（Apple silicon を搭載する端末）：<strong>Rosetta 2 がインストールされていること</strong>
<ul>
<li>以上 2 つは、<a href="https://docs.docker.com/docker-for-mac/install/#system-requirements">Docker のヘルプページ</a>の内容に基づきます。</li>
</ul>
</li>
<li>Windows：Windows 10（詳細なバージョンは <a href="https://docs.docker.com/docker-for-windows/install/#system-requirements">Docker のヘルプページ</a>を参照してください。Windows の Edition（例えば Windows 10 Home や Windows 10 Pro など）によってバージョンが異なります。）</li>
</ul>
<h3>→ 解決方法</h3>
<p>OS のアップデートを試してください。</p>
<ul>
<li>macOS をお使いの方は、<a href="https://support.apple.com/ja-jp/HT201541">Apple のサポートページ</a>を参照してください。</li>
<li>Windows をお使いの方は、<a href="https://support.microsoft.com/ja-jp/windows/windows-10-%E3%82%92%E6%9B%B4%E6%96%B0%E3%81%99%E3%82%8B-3c5ae7fc-9fb6-9af1-1984-b5e0412c556a">Microsoft のサポートページ</a>を参照してください。</li>
</ul>
<p>なお、今後も OS のバージョンが古くなると、Docker が動かなくなる可能性があります。OS はこまめにアップデートすると良いでしょう。</p>
<br>
<h2>(2) <code>docker compose up -d</code> （コンテナ起動）で失敗する<a id="2"></a></h2>
<h3>問題詳細</h3>
<p>Docker Desktop のインストールには成功したものの、コンテナ起動に失敗する場合があります。<br>
複数の原因が考えられます。</p>
<ul>
<li><a href="#2-1">・原因1（Windows、Mac）</a></li>
<li><a href="#2-2">・原因2（Windows、Mac）</a></li>
<li><a href="#2-3">・原因3（Windows、Mac）</a></li>
<li><a href="#2-4">・原因4（Windows のみ）</a></li>
</ul>
<h3>原因1（Windows、Mac）<a id="2-1"></a></h3>
<p>そもそも Docker Desktop が起動していない場合 <code>docker</code> コマンドを使用することはできません。<br>
デフォルトでは Docker Desktop は PC 起動時に同時に立ち上がる設定になっていることが多いのですが、PC の状態により起動していないケースもあります。</p>
<p>Docker Desktop が起動している場合、タスクバー（Windows）やメニューバー（Mac）にクジラのアイコンが <strong>止まって</strong> 表示されます。
なお、クジラのアイコンが動いているのは起動中という意味です。</p>
<p>また、コマンドラインからも Docker Desktop のステータスを確認できます。</p>
<pre><code>docker version
</code></pre>
<p>というコマンドを入力した際に</p>
<pre><code>Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?
</code></pre>
<p>や</p>
<pre><code>Error response from daemon: dial unix docker.raw.sock: connect: connection refused
</code></pre>
<p>というメッセージが表示されなければ、正しく起動できているはずです。</p>
<h3>→ 原因1の解決方法</h3>
<p>アプリケーション一覧から Docker のアイコンをクリックします。<br>
Docker Desktop が起動した後、<code>docker</code> コマンドが使えるか確認してみてください。</p>
<p>また、Docker が自動起動していない場合は、下記の手順で自動起動の設定ができます。</p>
<p>まず、Docker Desktop の歯車アイコン(Settings)をクリックします。</p>
<p><img src="/faq/images/intro/docker-settings-01.png" alt="DockerDesktopの設定を開く"></p>
<p>「Settings」の画面が開いたら、<br>
「Start Docker Desktop when you log in」をチェックし、<br>
「Open Docker Dashboard at startup」のチェックを外します。<br>
そして、「Apply &#x26; Restart」をクリックしてください。</p>
<p><img src="/faq/images/intro/docker-settings-02.png" alt="設定を変更する"></p>
<p>設定が終ったら、 PC を再起動した後にも <code>docker</code> コマンドが使えるか確認してみてください。</p>
<br>
<h3>原因2（Windows、Mac）<a id="2-2"></a></h3>
<p>他の起動中の Docker コンテナと衝突して、新しくコンテナが起動できないことがあります。</p>
<p>例えば、次のようなエラーが表示されます。</p>
<pre><code>Starting sample_app_1 ... error

ERROR: for sample_app_1  Cannot start service app: driver failed programming external connectivity on endpoint sample_app_1 (5xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx0): Bind for 0.0.0.0:8000 failed: port is already allocated

...
</code></pre>
<h3>→ 原因2の解決方法</h3>
<p>どのディレクトリのコンテナが衝突しているかわかる場合は、当該ディレクトリに移動してコンテナを終了・破棄します。</p>
<pre><code>docker compose down
</code></pre>
<p>わからない場合は、次のように<strong>全てのコンテナを終了・破棄</strong>します（コンテナは原則破棄するものなので、特に悪影響はありません）。</p>
<pre><code>docker stop $(docker ps -aq)
docker rm $(docker ps -aq)
</code></pre>
<p>再度起動したいコンテナのディレクトリに移動して、<code>docker compose up -d</code> を試してみてください。</p>
<br>
<h3>原因3（Windows、Mac）<a id="2-3"></a></h3>
<p>Docker Desktop が正常に起動していない場合、次のように表示される場合があります。</p>
<pre><code>Traceback (most recent call last):
  File "urllib3/connectionpool.py", line 670, in urlopen
  File "urllib3/connectionpool.py", line 392, in _make_request
  File "http/client.py", line 1255, in request
  File "http/client.py", line 1301, in _send_request
  File "http/client.py", line 1250, in endheaders
...
</code></pre>
<h3>→ 原因3の解決方法</h3>
<p>Docker Desktop を再起動してみてください。</p>
<br>
<h3>原因4（Windows ユーザー向け）<a id="2-4"></a></h3>
<p>やや特殊ですが、過去に Docker Desktop ではなく <a href="https://docs.docker.jp/toolbox/overview.html">Docker Toolbox</a> を使って Docker を使用した経験のある方は、その際の設定が誤って読み込まれてしまうことがあります。</p>
<p>具体的には、以下のような環境変数が Docker Toolbox によって設定されてしまうことが問題になります。</p>
<pre><code>DOCKER_HOST
DOCKER_CERT_PATH
DOCKER_TLS_VERIFY
DOCKER_MACHINE_NAME
</code></pre>
<h3>→ 原因4の解決方法</h3>
<p><code>DOCKER_</code> で始まる環境変数を一括して削除します。</p>
<p>管理者権限で PowerShell を起動し、</p>
<pre><code>Remove-Item Env:DOCKER_*
</code></pre>
<p>と入力してください。</p>
<h2>(3) <code>(winpty) docker compose exec app bash</code> で失敗する <a id="3"></a></h2>
<h3>表記について</h3>
<p>ここでは、表記を簡単にするため、<strong>Windows でのコマンドと Mac でのコマンドをまとめて「<code>(winpty) docker compose exec app bash</code>」と書きます</strong>。そのため、Windows の場合は「<code>winpty docker compose exec app bash</code>」に、Mac の場合は「<code>docker compose exec app bash</code>」に、それぞれ読み替えてください。</p>
<h3>問題詳細</h3>
<p><code>docker compose up -d</code>（コンテナ起動）には成功したものの、<code>(winpty) docker compose exec app bash</code> でコンテナに入れない場合があります。</p>
<h3>原因</h3>
<p>Dockerfile を一度変更したことがあるにもかかわらず、<code>docker compose build</code> でイメージをビルドし直していない可能性があります。</p>
<h3>→解決方法</h3>
<p><code>docker compose up build</code> 実行した後に、<code>docker compose up -d</code>（コンテナ起動） を実行し、 <code>(winpty) docker compose exec app bash</code> を実行してみてください。</p>
<h2>(4) PostgreSQL のバージョンを上げるとデータベースのコンテナの起動に失敗する <a id="4"></a></h2>
<h3>表記について</h3>
<p>ここでは、表記を簡単にするため、<strong>Windows でのコマンドと Mac でのコマンドをまとめて「<code>(winpty) docker compose exec app bash</code>」と書きます</strong>。そのため、Windows の場合は「<code>winpty docker compose exec app bash</code>」に、Mac の場合は「<code>docker compose exec app bash</code>」に、それぞれ読み替えてください。</p>
<p>また、PostgreSQL のコンテナを「db コンテナ」と呼ぶことにします。</p>
<h3>問題詳細</h3>
<p>db コンテナにアクセスする際や、db コンテナにアクセスするソフトウェアを使用する際にエラーが発生することがあります。例えば Sequalize を使用している場合は SequelizeHostNotFoundError が発生します。</p>
<h3>原因</h3>
<p>db コンテナが参照しているデータベースファイルのバージョンが古く、db コンテナの起動に失敗している可能性があります。</p>
<p>docker compose を使用している場合は、<code>docker compose logs</code> でコンテナのログを確認することができます。おそらく</p>
<pre><code>Attaching to schedule-arranger_app_1, schedule-arranger_db_1
app_1  | Welcome to Node.js v14.15.4.
app_1  | Type ".help" for more information.
db_1   |
db_1   | PostgreSQL Database directory appears to contain a database; Skipping initialization
db_1   |
db_1   | 20XX-XX-XX XX:XX:XX.XXX JST [1] FATAL:  データベースファイルがサーバと互換性がありません
db_1   | 20XX-XX-XX XX:XX:XX.XXX JST [1] 詳細:  データディレクトリはPostgreSQLバージョン12で初期化されましたが、これはバージョン14.2 (Debian 14.2-1.pgdg110+1)とは互換性がありません
</code></pre>
<p>または</p>
<pre><code>db_1   | 20XX-XX-XX XX:XX:XX.XXX JST [1] FATAL:  database files are incompatible with server
db_1   | 20XX-XX-XX XX:XX:XX.XXX JST [1] DETAIL:  The data directory was initialized by PostgreSQL version 12, which is not compatible with this version 14.2 (Debian 14.2-1.pgdg110+1).
</code></pre>
<p>のように表示され、データベースファイルのバージョンが古いことが原因であると分かります。</p>
<h3>→解決方法</h3>
<p>解決方法としては</p>
<ul>
<li>データベースを作り直す</li>
<li>データベースを消さず、新しいバージョンの PostgreSQL 用にデータベースをアップグレードする</li>
</ul>
<p>などが考えられます。<br>
前者は簡単ではありますが、<strong>データベースの中身が失われてしまう</strong>ことに注意してください。</p>
<p>データベースの中身を失いたくない場合や、<strong>Web サービスとして公開した場合</strong>はデータベースのアップグレードをするようにしてください。</p>
<table>
  <thead>
    <tr>
      <th rowspan="2"></td>
      <th colspan="2">
        docker volume コマンドで作成したボリュームを使っている
      </td>
    </tr>
    <tr>
      <th>はい</td>
      <th>いいえ</td>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>データベースを作り直したい</th>
      <td><a href="#4-1-2">方法1-2</a></td>
      <td><a href="#4-1-1">方法1-1</a></td>
    </tr>
    <tr>
      <th>データベースをアップグレードしたい</th>
      <td><a href="#4-2">方法2</a></td>
      <td><a href="#4-2">方法2</a> (★以外)</td>
    </tr>
  </tbody>
</table>
<h4>方法1-1: データベースを作り直す <a id="4-1-1"></a></h4>
<p>データベースファイルのあるディレクトリを空にしてください。次回のコンテナ立ち上げ時に再び必要なファイルが作り直され、互換性の問題は解決するはずです。</p>
<h4>方法1-2: データベースを作り直す (docker volume コマンドを使っている場合) <a id="4-1-2"></a></h4>
<p><strong>docker volume コマンドにより作成したボリュームにデータベースファイルを設置している場合は</strong>以下のようにして volume を作り直してください。</p>
<p>まず、</p>
<pre><code>docker compose down
</code></pre>
<p>でコンテナを閉じます。次に</p>
<pre><code>docker volume rm [データベースファイルのあるvolume名]
docker volume create --name=[データベースファイルのあるvolume名]
</code></pre>
<p>でデータベース用の volume を作り直します。<code>[データベースファイルのあるvolume名]</code> は例えば <code>my-application-data</code> など、現在使っているデータベース用 volume の名前で読み替えてください。
1行目では volume の削除を、2行目では volume の作成をしています。</p>
<p>Volume を作り直す、またはデータベースファイルのあるディレクトリを空にしたら</p>
<pre><code>docker compose up -d
(winpty) docker compose exec app bash
</code></pre>
<p>と入力し app コンテナに再び入ります。
コンテナに入れたら、エラーが発生したソフトウェアを再度実行してみましょう。
実行時にエラーが起こらなければ成功です。</p>
<h4>方法2: データベースをアップグレードする <a id="4-2"></a></h4>
<hr>
<p>注) 方法 2 内で用いられる「★」は <code>docker volume</code> コマンドにより作成したボリュームをデータベース用ボリュームとして用いている方向けの解説です。それ以外の方は読み飛ばして構いません。</p>
<hr>
<p>ここでは例として、<code>docker volume</code> で作成したボリューム内のデータベースファイルを PostgreSQL 12 対応のものから 14 対応のものへアップグレードする方法を紹介します。docker volume コマンドにより作成したボリュームを使用していない場合も以下と同様に dump の出力と読み込みをすることで移行できます。</p>
<p>まず、データベースの Dockerfile を</p>
<pre><code>FROM postgres:12
</code></pre>
<p>など、<strong>現在のデータベースファイルと互換性のあるバージョン</strong>に書き換えます。</p>
<p>次に</p>
<pre><code>docker compose up --build -d 
</code></pre>
<p>でコンテナを立ち上げます。Dockerfile を書き換えたので <code>--build</code> オプションをつけてビルドしています。</p>
<p>立ち上げたら、次のコマンドで <strong>dump</strong> を出力してください。ここでの dump とは、データベースの中身を SQL コマンドを含んだスクリプトで表したもののことを言います。dump ファイル内のスクリプトを実行することで、現在のデータベースの情報を復元することができます。</p>
<pre><code>docker compose exec db pg_dumpall --clean --no-role-passwords -U postgres > db.out
</code></pre>
<p>このコマンドを実行することで、現在のディレクトリにデータベースの dump である db.out が生成されます。コマンドの実行に失敗した場合は、PostgreSQL のバージョンが volume 内のデータベースファイルと互換性のないものである可能性があります。</p>
<details>
<summary>コマンドの説明 (クリックで展開)</summary>
<hr>
<pre><code>docker compose exec &#x3C;service> &#x3C;command>
</code></pre>
<p>は <code>&#x3C;service></code> コンテナに入り、<code>&#x3C;command></code> コマンドを実行するコマンドです。ここでは db コンテナに入り、<code>pg_dumpall</code> コマンドを実行しています。</p>
<pre><code>pg_dumpall --clean --no-role-passwords -U postgres
</code></pre>
<p>はデータベースの dump を出力する PostgreSQL のコマンドです。</p>
<p><code>--clean</code> は移行先にデータベースが存在した場合も DROP して作り直すオプションです。</p>
<p><code>--no-role-password</code> はロールのパスワードを出力しないオプションです。現在使用しているソフトウェアでデータベースのパスワード認証を利用していない場合は、このオプションが必要になります。</p>
<p><code>-U</code> は dump するユーザを指定するオプションです。ここではユーザ <code>postgres</code> を指定しています。</p>
<p>最後に <code>> db.out</code> で現在のディレクトリに <code>pg_dumpall</code> の出力を db.out として保存します。</p>
<hr>
</details>
<p>次にデータベースのバージョンを上げるため、一度コンテナを閉じます。</p>
<pre><code>docker compose down
</code></pre>
<p>db コンテナに使う Dockerfile の FROM の部分を</p>
<pre><code>FROM postgres:14.2
</code></pre>
<p>など移行先のバージョンに書き換えます。</p>
<h5>volume のバックアップ (★ docker volume コマンドを使っている場合)</h5>
<p>今 volume 内には古いデータベースが残っているため、このままコンテナを立ち上げると db コンテナの立ち上げに失敗してしまいます。そこで、volume を一度丸ごと削除して作り直します。</p>
<p>その前に、念のために <strong>volume のバックアップ</strong>を取っておきます。次のコマンドでバックアップ用の volume を作ります。ここではバックアップ用の volume 名を database-backup としています。</p>
<pre><code>docker volume create --name=database-backup
</code></pre>
<p>次に元のデータベース volume (ここでは my-application-data とします) の中身をバックアップ volume にコピーします。</p>
<p>Docker には volume をコピーするコマンドがないので、次のように<strong>新たにコンテナを作ることにより</strong>コピーします。(volume のリネームもできないため、リネームしたい場合もこの手順を踏む必要があります)</p>
<p>次のコマンドを実行してください。</p>
<pre><code>docker run --rm -v my-application-data:/from -v database-backup:/to alpine cp -a /from/. /to
</code></pre>
<p>これを実行することで、my-application-data の中身が database-backup にコピーされます。</p>
<details>
<summary>コマンドの説明 (クリックで展開)</summary>
<hr>
<pre><code>docker run [options] &#x3C;image> [command]
</code></pre>
<p>は指定した Docker イメージ <code>&#x3C;image></code> からコンテナを作り起動するコマンドです。<code>[options]</code> にはオプション、<code>[command]</code> にはコンテナ立ち上げ後にコンテナ内で実行するコマンドを指定します。</p>
<p><code>--rm</code> はコンテナ終了後にコンテナを削除するオプションです。</p>
<p>2つの <code>-v</code> オプションでは、</p>
<ul>
<li>コピー元の my-application-data をコンテナ内の <code>/from</code> にマウントすること</li>
<li>コピー先の database-backup を <code>/to</code> にマウントすること</li>
</ul>
<p>を指示しています。</p>
<p><a href="https://hub.docker.com/_/alpine">alpine</a> は軽量な Linux ディストリビューションである Alpine Linux の Docker イメージです。今回はファイルコピーという単純な作業のみをするので alpine を指定しています。そして <code>[command]</code> として</p>
<pre><code>cp -a /from/. /to
</code></pre>
<p>を指定しています。コンテナ実行後、上記コマンドにより <code>/from</code> の中身は <code>/to</code> にコピーされます。<code>/from</code> と <code>/to</code> はそれぞれ my-application-data と database-backup が対応するので、これで volume のコピーができたことになります。</p>
<hr>
</details>
<p>念のため、database-backup volume にデータがコピーされたかどうか確認してみましょう。</p>
<pre><code>docker run --rm -v database-backup:/volume alpine ls /volume
</code></pre>
<p>以上のコマンドでバックアップ volume の中身を確認することができます。うまくコピーされていれば成功です。</p>
<h4>volume の消去とデータベースの読み込み</h4>
<p>さて、volume のバックアップが取れたので元の volume を作り直します。
次のコマンドを実行してください(★)。</p>
<pre><code>docker volume rm my-application-data
docker volume create --name=my-application-data
</code></pre>
<p><code>docker volume</code> によるボリュームを<strong>用いていない</strong>場合は適切なディレクトリの中身を削除してください。この際、ディレクトリのバックアップを忘れないようにしましょう。
例えば <code>~/workspace/db/</code> にデータベースがあった場合、次のようにしてバックアップとディレクトリの中身の削除ができます。</p>
<pre><code>cd ~/workspace

# db を db-backup にリネーム
mv db db-backup 

# db フォルダを作り直す
mkdir db
</code></pre>
<p>volume を作りなおせたらコンテナを立ち上げます。また、先ほど Dockerfile を書き換えたのでビルドも忘れずにしましょう。</p>
<pre><code>docker compose up --build -d
</code></pre>
<p>次に、データベースを新しいバージョンの PostgreSQL に読み込みます。次のコマンドを実行してください。</p>
<pre><code>cat db.out | docker compose exec -T db psql -f - -U postgres
</code></pre>
<details>
<summary>コマンドの説明 (クリックで展開)</summary>
<hr>
<p><code>cat db.out</code> で db.out の中身を標準出力します。これをパイプ (<code>|</code>) で <code>docker compose</code> コマンドに渡します。
<code>docker compose exec</code> の <code>-T</code> は標準入力を受け取るために必要なオプションです。</p>
<p>db コンテナ内で実行する <code>psql</code> コマンドは PostgreSQL を実行するコマンドです。<code>-f</code> オプションは読み込むファイルを指定するオプションです。指定したファイル名が <code>-</code> であるとき、標準入力を受け取ります。また、<code>-U</code> オプションでは読み込むときに使用するユーザ名を指定します。</p>
<hr>
</details>
<p>これで読み込みが成功しているはずです。</p>
<h5>実行確認</h5>
<p>最後に実際にデータベースが移行できているか確認してみましょう。エラーが発生していたソフトウェアを再度実行してください。これでエラーが出ず、無事に起動できれば成功です。</p>
<p>パスワード認証エラー等が出た場合は dump 時に <code>--no-role-password</code> オプションを指定していたかを確認してみてください。</p>
<h5>移行に失敗した場合は</h5>
<p>移行に失敗した場合は次の手順でもとに戻すことができます。</p>
<h6>★ docker volume コマンドを使っている場合</h6>
<p>まず <code>docker compose down</code> でコンテナを閉じてから</p>
<pre><code># my-application-data を消去して作り直す
docker volume rm my-application-data
docker volume create --name=my-application-data

# バックアップから復元
docker run --rm -v database-backup:/from -v my-application-data:/to alpine cp -a /from/. /to
</code></pre>
<p>を実行します。これで my-application-data には古いバージョンのデータベースが復元されました。</p>
<h6>docker volume コマンドを使っていない場合</h6>
<p>元のデータベースをバックアップを、データベースを置いていたディレクトリに戻します。データベースの存在するディレクトリが <code>~/workspace/db/</code> 、バックアップが <code>~/workspace/db-backup/</code> にある場合は次のようにしてバックアップを復元できます。</p>
<pre><code>cd ~/workspace

# db を削除
rm -rf db

# db-backup を db にリネーム
mv db-backup db
</code></pre>
<h5>移行に成功した場合の後片付け</h5>
<p>移行に成功したと判断できたら、以下のコマンドを実行することで</p>
<ul>
<li>バックアップ用 volume (★)</li>
<li>データベースの dump</li>
</ul>
<p>を削除することができます。</p>
<pre><code>docker volume rm database-backup
rm db.out
</code></pre>
<h2>(5) npx prisma で失敗する。または Intel MacBook にて Docker を利用していると Segmentation fault と表示される。 <a id="5"></a></h2>
<h3>問題詳細</h3>
<p>コンテナのコンソール上で、 <code>npx prisma init</code> といった <code>npx prisma</code> から始まるコマンドを実行すると、 <code>Segmentation fault</code> と表示されて動作しない。</p>
<p>または、Intel MacBook において、 Docker を利用していると、 <code>Segmentation fault</code> というエラーが表示される場合がある。</p>
<h3>原因</h3>
<p>Intel 製のチップを搭載した MacBook において、 Virtualization Framework というものが有効になっている際に起こる不具合です。
これは、 Docker Desktop v19.0.0 以上で発生が確認されています。</p>
<p>下記のサイトでこちらの不具合は把握されています。</p>
<p><a href="https://github.com/docker/for-mac/issues/6824">Docker Desktop for mac での issue</a></p>
<h3>→解決方法</h3>
<p>ファイル共有システムに利用している VirtioFS が Virtualization Framework を利用しています。<br>
ですから、ファイル共有システムを他のものへと変更することで、原因である Virtualization Framework を無効化する必要があります。</p>
<p>そのために、Docker Desktop の設定を変更します。</p>
<p>まず、 Docker Desktop を開いてください。</p>
<p>開いたら、画像で示した右上にある、歯車マークをクリックしてください。</p>
<p><img src="/faq/images/intro/how-to-set-grpc-1.png" alt="Docker Desktop のホーム画面"></p>
<p>クリックすると、以下のような設定画面が表示されます。</p>
<p>下の方へスクロールすると、画像で示したように、「Choose file sharing implementation for your containers」 と書かれた部分があります。</p>
<p><img src="/faq/images/intro/how-to-set-grpc-2.png" alt="Docker Desktop の設定画面"></p>
<p>これを以下の画像の指示に沿って、「gRPC FUSE」に変更してください。</p>
<p><img src="/faq/images/intro/how-to-set-grpc-3.png" alt="ファイル共有システムを gRPC FUSE に変更"></p>
<p>すると、上の「Use Virtualization framework」 と書かれた部分のチェックを変更できるようになります。<br>
このチェックを外すことで、「Virtualization framework」を無効化できます。</p>
<p>以下の画像を参考に、このチェックを外し、右下の「Apply &#x26; restart」 をクリックしてください。</p>
<p><img src="/faq/images/intro/how-to-set-grpc-4.png" alt="Virtualization framework を無効化"></p>
<p>これによって Virtualization Framework を無効化でき、エラーが解消されるはずです。</p>
<p>なお、以前より Docker を利用した際の挙動が重くなる可能性があります。</p>
</div></div></main><footer class=""><hr/><div class="px-5 pt-3 pb-5 bg-gray-700 text-sm text-white font-bold"><div class="max-w-4xl mx-auto"><span><a href="/faq/">FAQ・トラブルシューティング - N予備校プログラミングコース</a></span></div></div></footer></div></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"post":{"title":"Docker 関連のトラブル","content":"\u003ch1\u003eDocker 関連のトラブル\u003c/h1\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e目次\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#1\"\u003e(1) Docker Desktop がインストールできない\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#2\"\u003e(2) docker compose up -d（コンテナ起動）で失敗する\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#3\"\u003e(3) (winpty) docker compose exec app bash で失敗する\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#4\"\u003e(4) PostgreSQL のバージョンを上げるとデータベースのコンテナの起動に失敗する\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#5\"\u003e(5) npx prisma で失敗する。または Intel MacBook にて Docker を利用していると Segmentation fault と表示される。\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2\u003e(1) Docker Desktop がインストールできない \u003ca id=\"1\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003ch3\u003e問題詳細\u003c/h3\u003e\n\u003cp\u003eコンピュータの記憶容量の残りが十分あるにもかかわらず、Docker Desktop がインストールできない場合があります。\u003c/p\u003e\n\u003ch3\u003e原因\u003c/h3\u003e\n\u003cp\u003eOS が Docker が対応していない古いバージョンであることが原因です。\nDocker が対応している OS のバージョンは、次の通りです（2021.7.12 最終確認）。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003emacOS（Intel の CPU を搭載する端末）：\u003cstrong\u003eバージョン 10.14（Mojave）以降\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003emacOS（Apple silicon を搭載する端末）：\u003cstrong\u003eRosetta 2 がインストールされていること\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e以上 2 つは、\u003ca href=\"https://docs.docker.com/docker-for-mac/install/#system-requirements\"\u003eDocker のヘルプページ\u003c/a\u003eの内容に基づきます。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eWindows：Windows 10（詳細なバージョンは \u003ca href=\"https://docs.docker.com/docker-for-windows/install/#system-requirements\"\u003eDocker のヘルプページ\u003c/a\u003eを参照してください。Windows の Edition（例えば Windows 10 Home や Windows 10 Pro など）によってバージョンが異なります。）\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e→ 解決方法\u003c/h3\u003e\n\u003cp\u003eOS のアップデートを試してください。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003emacOS をお使いの方は、\u003ca href=\"https://support.apple.com/ja-jp/HT201541\"\u003eApple のサポートページ\u003c/a\u003eを参照してください。\u003c/li\u003e\n\u003cli\u003eWindows をお使いの方は、\u003ca href=\"https://support.microsoft.com/ja-jp/windows/windows-10-%E3%82%92%E6%9B%B4%E6%96%B0%E3%81%99%E3%82%8B-3c5ae7fc-9fb6-9af1-1984-b5e0412c556a\"\u003eMicrosoft のサポートページ\u003c/a\u003eを参照してください。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eなお、今後も OS のバージョンが古くなると、Docker が動かなくなる可能性があります。OS はこまめにアップデートすると良いでしょう。\u003c/p\u003e\n\u003cbr\u003e\n\u003ch2\u003e(2) \u003ccode\u003edocker compose up -d\u003c/code\u003e （コンテナ起動）で失敗する\u003ca id=\"2\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003ch3\u003e問題詳細\u003c/h3\u003e\n\u003cp\u003eDocker Desktop のインストールには成功したものの、コンテナ起動に失敗する場合があります。\u003cbr\u003e\n複数の原因が考えられます。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#2-1\"\u003e・原因1（Windows、Mac）\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#2-2\"\u003e・原因2（Windows、Mac）\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#2-3\"\u003e・原因3（Windows、Mac）\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#2-4\"\u003e・原因4（Windows のみ）\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e原因1（Windows、Mac）\u003ca id=\"2-1\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eそもそも Docker Desktop が起動していない場合 \u003ccode\u003edocker\u003c/code\u003e コマンドを使用することはできません。\u003cbr\u003e\nデフォルトでは Docker Desktop は PC 起動時に同時に立ち上がる設定になっていることが多いのですが、PC の状態により起動していないケースもあります。\u003c/p\u003e\n\u003cp\u003eDocker Desktop が起動している場合、タスクバー（Windows）やメニューバー（Mac）にクジラのアイコンが \u003cstrong\u003e止まって\u003c/strong\u003e 表示されます。\nなお、クジラのアイコンが動いているのは起動中という意味です。\u003c/p\u003e\n\u003cp\u003eまた、コマンドラインからも Docker Desktop のステータスを確認できます。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edocker version\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eというコマンドを入力した際に\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eCannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eや\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eError response from daemon: dial unix docker.raw.sock: connect: connection refused\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eというメッセージが表示されなければ、正しく起動できているはずです。\u003c/p\u003e\n\u003ch3\u003e→ 原因1の解決方法\u003c/h3\u003e\n\u003cp\u003eアプリケーション一覧から Docker のアイコンをクリックします。\u003cbr\u003e\nDocker Desktop が起動した後、\u003ccode\u003edocker\u003c/code\u003e コマンドが使えるか確認してみてください。\u003c/p\u003e\n\u003cp\u003eまた、Docker が自動起動していない場合は、下記の手順で自動起動の設定ができます。\u003c/p\u003e\n\u003cp\u003eまず、Docker Desktop の歯車アイコン(Settings)をクリックします。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/faq/images/intro/docker-settings-01.png\" alt=\"DockerDesktopの設定を開く\"\u003e\u003c/p\u003e\n\u003cp\u003e「Settings」の画面が開いたら、\u003cbr\u003e\n「Start Docker Desktop when you log in」をチェックし、\u003cbr\u003e\n「Open Docker Dashboard at startup」のチェックを外します。\u003cbr\u003e\nそして、「Apply \u0026#x26; Restart」をクリックしてください。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/faq/images/intro/docker-settings-02.png\" alt=\"設定を変更する\"\u003e\u003c/p\u003e\n\u003cp\u003e設定が終ったら、 PC を再起動した後にも \u003ccode\u003edocker\u003c/code\u003e コマンドが使えるか確認してみてください。\u003c/p\u003e\n\u003cbr\u003e\n\u003ch3\u003e原因2（Windows、Mac）\u003ca id=\"2-2\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e他の起動中の Docker コンテナと衝突して、新しくコンテナが起動できないことがあります。\u003c/p\u003e\n\u003cp\u003e例えば、次のようなエラーが表示されます。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eStarting sample_app_1 ... error\n\nERROR: for sample_app_1  Cannot start service app: driver failed programming external connectivity on endpoint sample_app_1 (5xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx0): Bind for 0.0.0.0:8000 failed: port is already allocated\n\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e→ 原因2の解決方法\u003c/h3\u003e\n\u003cp\u003eどのディレクトリのコンテナが衝突しているかわかる場合は、当該ディレクトリに移動してコンテナを終了・破棄します。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edocker compose down\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eわからない場合は、次のように\u003cstrong\u003e全てのコンテナを終了・破棄\u003c/strong\u003eします（コンテナは原則破棄するものなので、特に悪影響はありません）。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edocker stop $(docker ps -aq)\ndocker rm $(docker ps -aq)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e再度起動したいコンテナのディレクトリに移動して、\u003ccode\u003edocker compose up -d\u003c/code\u003e を試してみてください。\u003c/p\u003e\n\u003cbr\u003e\n\u003ch3\u003e原因3（Windows、Mac）\u003ca id=\"2-3\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eDocker Desktop が正常に起動していない場合、次のように表示される場合があります。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eTraceback (most recent call last):\n  File \"urllib3/connectionpool.py\", line 670, in urlopen\n  File \"urllib3/connectionpool.py\", line 392, in _make_request\n  File \"http/client.py\", line 1255, in request\n  File \"http/client.py\", line 1301, in _send_request\n  File \"http/client.py\", line 1250, in endheaders\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e→ 原因3の解決方法\u003c/h3\u003e\n\u003cp\u003eDocker Desktop を再起動してみてください。\u003c/p\u003e\n\u003cbr\u003e\n\u003ch3\u003e原因4（Windows ユーザー向け）\u003ca id=\"2-4\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eやや特殊ですが、過去に Docker Desktop ではなく \u003ca href=\"https://docs.docker.jp/toolbox/overview.html\"\u003eDocker Toolbox\u003c/a\u003e を使って Docker を使用した経験のある方は、その際の設定が誤って読み込まれてしまうことがあります。\u003c/p\u003e\n\u003cp\u003e具体的には、以下のような環境変数が Docker Toolbox によって設定されてしまうことが問題になります。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eDOCKER_HOST\nDOCKER_CERT_PATH\nDOCKER_TLS_VERIFY\nDOCKER_MACHINE_NAME\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e→ 原因4の解決方法\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eDOCKER_\u003c/code\u003e で始まる環境変数を一括して削除します。\u003c/p\u003e\n\u003cp\u003e管理者権限で PowerShell を起動し、\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eRemove-Item Env:DOCKER_*\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eと入力してください。\u003c/p\u003e\n\u003ch2\u003e(3) \u003ccode\u003e(winpty) docker compose exec app bash\u003c/code\u003e で失敗する \u003ca id=\"3\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003ch3\u003e表記について\u003c/h3\u003e\n\u003cp\u003eここでは、表記を簡単にするため、\u003cstrong\u003eWindows でのコマンドと Mac でのコマンドをまとめて「\u003ccode\u003e(winpty) docker compose exec app bash\u003c/code\u003e」と書きます\u003c/strong\u003e。そのため、Windows の場合は「\u003ccode\u003ewinpty docker compose exec app bash\u003c/code\u003e」に、Mac の場合は「\u003ccode\u003edocker compose exec app bash\u003c/code\u003e」に、それぞれ読み替えてください。\u003c/p\u003e\n\u003ch3\u003e問題詳細\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003edocker compose up -d\u003c/code\u003e（コンテナ起動）には成功したものの、\u003ccode\u003e(winpty) docker compose exec app bash\u003c/code\u003e でコンテナに入れない場合があります。\u003c/p\u003e\n\u003ch3\u003e原因\u003c/h3\u003e\n\u003cp\u003eDockerfile を一度変更したことがあるにもかかわらず、\u003ccode\u003edocker compose build\u003c/code\u003e でイメージをビルドし直していない可能性があります。\u003c/p\u003e\n\u003ch3\u003e→解決方法\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003edocker compose up build\u003c/code\u003e 実行した後に、\u003ccode\u003edocker compose up -d\u003c/code\u003e（コンテナ起動） を実行し、 \u003ccode\u003e(winpty) docker compose exec app bash\u003c/code\u003e を実行してみてください。\u003c/p\u003e\n\u003ch2\u003e(4) PostgreSQL のバージョンを上げるとデータベースのコンテナの起動に失敗する \u003ca id=\"4\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003ch3\u003e表記について\u003c/h3\u003e\n\u003cp\u003eここでは、表記を簡単にするため、\u003cstrong\u003eWindows でのコマンドと Mac でのコマンドをまとめて「\u003ccode\u003e(winpty) docker compose exec app bash\u003c/code\u003e」と書きます\u003c/strong\u003e。そのため、Windows の場合は「\u003ccode\u003ewinpty docker compose exec app bash\u003c/code\u003e」に、Mac の場合は「\u003ccode\u003edocker compose exec app bash\u003c/code\u003e」に、それぞれ読み替えてください。\u003c/p\u003e\n\u003cp\u003eまた、PostgreSQL のコンテナを「db コンテナ」と呼ぶことにします。\u003c/p\u003e\n\u003ch3\u003e問題詳細\u003c/h3\u003e\n\u003cp\u003edb コンテナにアクセスする際や、db コンテナにアクセスするソフトウェアを使用する際にエラーが発生することがあります。例えば Sequalize を使用している場合は SequelizeHostNotFoundError が発生します。\u003c/p\u003e\n\u003ch3\u003e原因\u003c/h3\u003e\n\u003cp\u003edb コンテナが参照しているデータベースファイルのバージョンが古く、db コンテナの起動に失敗している可能性があります。\u003c/p\u003e\n\u003cp\u003edocker compose を使用している場合は、\u003ccode\u003edocker compose logs\u003c/code\u003e でコンテナのログを確認することができます。おそらく\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eAttaching to schedule-arranger_app_1, schedule-arranger_db_1\napp_1  | Welcome to Node.js v14.15.4.\napp_1  | Type \".help\" for more information.\ndb_1   |\ndb_1   | PostgreSQL Database directory appears to contain a database; Skipping initialization\ndb_1   |\ndb_1   | 20XX-XX-XX XX:XX:XX.XXX JST [1] FATAL:  データベースファイルがサーバと互換性がありません\ndb_1   | 20XX-XX-XX XX:XX:XX.XXX JST [1] 詳細:  データディレクトリはPostgreSQLバージョン12で初期化されましたが、これはバージョン14.2 (Debian 14.2-1.pgdg110+1)とは互換性がありません\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eまたは\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edb_1   | 20XX-XX-XX XX:XX:XX.XXX JST [1] FATAL:  database files are incompatible with server\ndb_1   | 20XX-XX-XX XX:XX:XX.XXX JST [1] DETAIL:  The data directory was initialized by PostgreSQL version 12, which is not compatible with this version 14.2 (Debian 14.2-1.pgdg110+1).\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eのように表示され、データベースファイルのバージョンが古いことが原因であると分かります。\u003c/p\u003e\n\u003ch3\u003e→解決方法\u003c/h3\u003e\n\u003cp\u003e解決方法としては\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eデータベースを作り直す\u003c/li\u003e\n\u003cli\u003eデータベースを消さず、新しいバージョンの PostgreSQL 用にデータベースをアップグレードする\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eなどが考えられます。\u003cbr\u003e\n前者は簡単ではありますが、\u003cstrong\u003eデータベースの中身が失われてしまう\u003c/strong\u003eことに注意してください。\u003c/p\u003e\n\u003cp\u003eデータベースの中身を失いたくない場合や、\u003cstrong\u003eWeb サービスとして公開した場合\u003c/strong\u003eはデータベースのアップグレードをするようにしてください。\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n    \u003ctr\u003e\n      \u003cth rowspan=\"2\"\u003e\u003c/td\u003e\n      \u003cth colspan=\"2\"\u003e\n        docker volume コマンドで作成したボリュームを使っている\n      \u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003cth\u003eはい\u003c/td\u003e\n      \u003cth\u003eいいえ\u003c/td\u003e\n    \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n    \u003ctr\u003e\n      \u003cth\u003eデータベースを作り直したい\u003c/th\u003e\n      \u003ctd\u003e\u003ca href=\"#4-1-2\"\u003e方法1-2\u003c/a\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003ca href=\"#4-1-1\"\u003e方法1-1\u003c/a\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003cth\u003eデータベースをアップグレードしたい\u003c/th\u003e\n      \u003ctd\u003e\u003ca href=\"#4-2\"\u003e方法2\u003c/a\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003ca href=\"#4-2\"\u003e方法2\u003c/a\u003e (★以外)\u003c/td\u003e\n    \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch4\u003e方法1-1: データベースを作り直す \u003ca id=\"4-1-1\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003eデータベースファイルのあるディレクトリを空にしてください。次回のコンテナ立ち上げ時に再び必要なファイルが作り直され、互換性の問題は解決するはずです。\u003c/p\u003e\n\u003ch4\u003e方法1-2: データベースを作り直す (docker volume コマンドを使っている場合) \u003ca id=\"4-1-2\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e\u003cstrong\u003edocker volume コマンドにより作成したボリュームにデータベースファイルを設置している場合は\u003c/strong\u003e以下のようにして volume を作り直してください。\u003c/p\u003e\n\u003cp\u003eまず、\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edocker compose down\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eでコンテナを閉じます。次に\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edocker volume rm [データベースファイルのあるvolume名]\ndocker volume create --name=[データベースファイルのあるvolume名]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eでデータベース用の volume を作り直します。\u003ccode\u003e[データベースファイルのあるvolume名]\u003c/code\u003e は例えば \u003ccode\u003emy-application-data\u003c/code\u003e など、現在使っているデータベース用 volume の名前で読み替えてください。\n1行目では volume の削除を、2行目では volume の作成をしています。\u003c/p\u003e\n\u003cp\u003eVolume を作り直す、またはデータベースファイルのあるディレクトリを空にしたら\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edocker compose up -d\n(winpty) docker compose exec app bash\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eと入力し app コンテナに再び入ります。\nコンテナに入れたら、エラーが発生したソフトウェアを再度実行してみましょう。\n実行時にエラーが起こらなければ成功です。\u003c/p\u003e\n\u003ch4\u003e方法2: データベースをアップグレードする \u003ca id=\"4-2\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003chr\u003e\n\u003cp\u003e注) 方法 2 内で用いられる「★」は \u003ccode\u003edocker volume\u003c/code\u003e コマンドにより作成したボリュームをデータベース用ボリュームとして用いている方向けの解説です。それ以外の方は読み飛ばして構いません。\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003eここでは例として、\u003ccode\u003edocker volume\u003c/code\u003e で作成したボリューム内のデータベースファイルを PostgreSQL 12 対応のものから 14 対応のものへアップグレードする方法を紹介します。docker volume コマンドにより作成したボリュームを使用していない場合も以下と同様に dump の出力と読み込みをすることで移行できます。\u003c/p\u003e\n\u003cp\u003eまず、データベースの Dockerfile を\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eFROM postgres:12\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eなど、\u003cstrong\u003e現在のデータベースファイルと互換性のあるバージョン\u003c/strong\u003eに書き換えます。\u003c/p\u003e\n\u003cp\u003e次に\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edocker compose up --build -d \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eでコンテナを立ち上げます。Dockerfile を書き換えたので \u003ccode\u003e--build\u003c/code\u003e オプションをつけてビルドしています。\u003c/p\u003e\n\u003cp\u003e立ち上げたら、次のコマンドで \u003cstrong\u003edump\u003c/strong\u003e を出力してください。ここでの dump とは、データベースの中身を SQL コマンドを含んだスクリプトで表したもののことを言います。dump ファイル内のスクリプトを実行することで、現在のデータベースの情報を復元することができます。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edocker compose exec db pg_dumpall --clean --no-role-passwords -U postgres \u003e db.out\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eこのコマンドを実行することで、現在のディレクトリにデータベースの dump である db.out が生成されます。コマンドの実行に失敗した場合は、PostgreSQL のバージョンが volume 内のデータベースファイルと互換性のないものである可能性があります。\u003c/p\u003e\n\u003cdetails\u003e\n\u003csummary\u003eコマンドの説明 (クリックで展開)\u003c/summary\u003e\n\u003chr\u003e\n\u003cpre\u003e\u003ccode\u003edocker compose exec \u0026#x3C;service\u003e \u0026#x3C;command\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eは \u003ccode\u003e\u0026#x3C;service\u003e\u003c/code\u003e コンテナに入り、\u003ccode\u003e\u0026#x3C;command\u003e\u003c/code\u003e コマンドを実行するコマンドです。ここでは db コンテナに入り、\u003ccode\u003epg_dumpall\u003c/code\u003e コマンドを実行しています。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epg_dumpall --clean --no-role-passwords -U postgres\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eはデータベースの dump を出力する PostgreSQL のコマンドです。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e--clean\u003c/code\u003e は移行先にデータベースが存在した場合も DROP して作り直すオプションです。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e--no-role-password\u003c/code\u003e はロールのパスワードを出力しないオプションです。現在使用しているソフトウェアでデータベースのパスワード認証を利用していない場合は、このオプションが必要になります。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e-U\u003c/code\u003e は dump するユーザを指定するオプションです。ここではユーザ \u003ccode\u003epostgres\u003c/code\u003e を指定しています。\u003c/p\u003e\n\u003cp\u003e最後に \u003ccode\u003e\u003e db.out\u003c/code\u003e で現在のディレクトリに \u003ccode\u003epg_dumpall\u003c/code\u003e の出力を db.out として保存します。\u003c/p\u003e\n\u003chr\u003e\n\u003c/details\u003e\n\u003cp\u003e次にデータベースのバージョンを上げるため、一度コンテナを閉じます。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edocker compose down\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003edb コンテナに使う Dockerfile の FROM の部分を\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eFROM postgres:14.2\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eなど移行先のバージョンに書き換えます。\u003c/p\u003e\n\u003ch5\u003evolume のバックアップ (★ docker volume コマンドを使っている場合)\u003c/h5\u003e\n\u003cp\u003e今 volume 内には古いデータベースが残っているため、このままコンテナを立ち上げると db コンテナの立ち上げに失敗してしまいます。そこで、volume を一度丸ごと削除して作り直します。\u003c/p\u003e\n\u003cp\u003eその前に、念のために \u003cstrong\u003evolume のバックアップ\u003c/strong\u003eを取っておきます。次のコマンドでバックアップ用の volume を作ります。ここではバックアップ用の volume 名を database-backup としています。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edocker volume create --name=database-backup\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e次に元のデータベース volume (ここでは my-application-data とします) の中身をバックアップ volume にコピーします。\u003c/p\u003e\n\u003cp\u003eDocker には volume をコピーするコマンドがないので、次のように\u003cstrong\u003e新たにコンテナを作ることにより\u003c/strong\u003eコピーします。(volume のリネームもできないため、リネームしたい場合もこの手順を踏む必要があります)\u003c/p\u003e\n\u003cp\u003e次のコマンドを実行してください。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edocker run --rm -v my-application-data:/from -v database-backup:/to alpine cp -a /from/. /to\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eこれを実行することで、my-application-data の中身が database-backup にコピーされます。\u003c/p\u003e\n\u003cdetails\u003e\n\u003csummary\u003eコマンドの説明 (クリックで展開)\u003c/summary\u003e\n\u003chr\u003e\n\u003cpre\u003e\u003ccode\u003edocker run [options] \u0026#x3C;image\u003e [command]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eは指定した Docker イメージ \u003ccode\u003e\u0026#x3C;image\u003e\u003c/code\u003e からコンテナを作り起動するコマンドです。\u003ccode\u003e[options]\u003c/code\u003e にはオプション、\u003ccode\u003e[command]\u003c/code\u003e にはコンテナ立ち上げ後にコンテナ内で実行するコマンドを指定します。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e--rm\u003c/code\u003e はコンテナ終了後にコンテナを削除するオプションです。\u003c/p\u003e\n\u003cp\u003e2つの \u003ccode\u003e-v\u003c/code\u003e オプションでは、\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eコピー元の my-application-data をコンテナ内の \u003ccode\u003e/from\u003c/code\u003e にマウントすること\u003c/li\u003e\n\u003cli\u003eコピー先の database-backup を \u003ccode\u003e/to\u003c/code\u003e にマウントすること\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eを指示しています。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://hub.docker.com/_/alpine\"\u003ealpine\u003c/a\u003e は軽量な Linux ディストリビューションである Alpine Linux の Docker イメージです。今回はファイルコピーという単純な作業のみをするので alpine を指定しています。そして \u003ccode\u003e[command]\u003c/code\u003e として\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ecp -a /from/. /to\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eを指定しています。コンテナ実行後、上記コマンドにより \u003ccode\u003e/from\u003c/code\u003e の中身は \u003ccode\u003e/to\u003c/code\u003e にコピーされます。\u003ccode\u003e/from\u003c/code\u003e と \u003ccode\u003e/to\u003c/code\u003e はそれぞれ my-application-data と database-backup が対応するので、これで volume のコピーができたことになります。\u003c/p\u003e\n\u003chr\u003e\n\u003c/details\u003e\n\u003cp\u003e念のため、database-backup volume にデータがコピーされたかどうか確認してみましょう。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edocker run --rm -v database-backup:/volume alpine ls /volume\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e以上のコマンドでバックアップ volume の中身を確認することができます。うまくコピーされていれば成功です。\u003c/p\u003e\n\u003ch4\u003evolume の消去とデータベースの読み込み\u003c/h4\u003e\n\u003cp\u003eさて、volume のバックアップが取れたので元の volume を作り直します。\n次のコマンドを実行してください(★)。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edocker volume rm my-application-data\ndocker volume create --name=my-application-data\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003edocker volume\u003c/code\u003e によるボリュームを\u003cstrong\u003e用いていない\u003c/strong\u003e場合は適切なディレクトリの中身を削除してください。この際、ディレクトリのバックアップを忘れないようにしましょう。\n例えば \u003ccode\u003e~/workspace/db/\u003c/code\u003e にデータベースがあった場合、次のようにしてバックアップとディレクトリの中身の削除ができます。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ecd ~/workspace\n\n# db を db-backup にリネーム\nmv db db-backup \n\n# db フォルダを作り直す\nmkdir db\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003evolume を作りなおせたらコンテナを立ち上げます。また、先ほど Dockerfile を書き換えたのでビルドも忘れずにしましょう。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edocker compose up --build -d\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e次に、データベースを新しいバージョンの PostgreSQL に読み込みます。次のコマンドを実行してください。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ecat db.out | docker compose exec -T db psql -f - -U postgres\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdetails\u003e\n\u003csummary\u003eコマンドの説明 (クリックで展開)\u003c/summary\u003e\n\u003chr\u003e\n\u003cp\u003e\u003ccode\u003ecat db.out\u003c/code\u003e で db.out の中身を標準出力します。これをパイプ (\u003ccode\u003e|\u003c/code\u003e) で \u003ccode\u003edocker compose\u003c/code\u003e コマンドに渡します。\n\u003ccode\u003edocker compose exec\u003c/code\u003e の \u003ccode\u003e-T\u003c/code\u003e は標準入力を受け取るために必要なオプションです。\u003c/p\u003e\n\u003cp\u003edb コンテナ内で実行する \u003ccode\u003epsql\u003c/code\u003e コマンドは PostgreSQL を実行するコマンドです。\u003ccode\u003e-f\u003c/code\u003e オプションは読み込むファイルを指定するオプションです。指定したファイル名が \u003ccode\u003e-\u003c/code\u003e であるとき、標準入力を受け取ります。また、\u003ccode\u003e-U\u003c/code\u003e オプションでは読み込むときに使用するユーザ名を指定します。\u003c/p\u003e\n\u003chr\u003e\n\u003c/details\u003e\n\u003cp\u003eこれで読み込みが成功しているはずです。\u003c/p\u003e\n\u003ch5\u003e実行確認\u003c/h5\u003e\n\u003cp\u003e最後に実際にデータベースが移行できているか確認してみましょう。エラーが発生していたソフトウェアを再度実行してください。これでエラーが出ず、無事に起動できれば成功です。\u003c/p\u003e\n\u003cp\u003eパスワード認証エラー等が出た場合は dump 時に \u003ccode\u003e--no-role-password\u003c/code\u003e オプションを指定していたかを確認してみてください。\u003c/p\u003e\n\u003ch5\u003e移行に失敗した場合は\u003c/h5\u003e\n\u003cp\u003e移行に失敗した場合は次の手順でもとに戻すことができます。\u003c/p\u003e\n\u003ch6\u003e★ docker volume コマンドを使っている場合\u003c/h6\u003e\n\u003cp\u003eまず \u003ccode\u003edocker compose down\u003c/code\u003e でコンテナを閉じてから\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# my-application-data を消去して作り直す\ndocker volume rm my-application-data\ndocker volume create --name=my-application-data\n\n# バックアップから復元\ndocker run --rm -v database-backup:/from -v my-application-data:/to alpine cp -a /from/. /to\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eを実行します。これで my-application-data には古いバージョンのデータベースが復元されました。\u003c/p\u003e\n\u003ch6\u003edocker volume コマンドを使っていない場合\u003c/h6\u003e\n\u003cp\u003e元のデータベースをバックアップを、データベースを置いていたディレクトリに戻します。データベースの存在するディレクトリが \u003ccode\u003e~/workspace/db/\u003c/code\u003e 、バックアップが \u003ccode\u003e~/workspace/db-backup/\u003c/code\u003e にある場合は次のようにしてバックアップを復元できます。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ecd ~/workspace\n\n# db を削除\nrm -rf db\n\n# db-backup を db にリネーム\nmv db-backup db\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch5\u003e移行に成功した場合の後片付け\u003c/h5\u003e\n\u003cp\u003e移行に成功したと判断できたら、以下のコマンドを実行することで\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eバックアップ用 volume (★)\u003c/li\u003e\n\u003cli\u003eデータベースの dump\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eを削除することができます。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edocker volume rm database-backup\nrm db.out\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e(5) npx prisma で失敗する。または Intel MacBook にて Docker を利用していると Segmentation fault と表示される。 \u003ca id=\"5\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003ch3\u003e問題詳細\u003c/h3\u003e\n\u003cp\u003eコンテナのコンソール上で、 \u003ccode\u003enpx prisma init\u003c/code\u003e といった \u003ccode\u003enpx prisma\u003c/code\u003e から始まるコマンドを実行すると、 \u003ccode\u003eSegmentation fault\u003c/code\u003e と表示されて動作しない。\u003c/p\u003e\n\u003cp\u003eまたは、Intel MacBook において、 Docker を利用していると、 \u003ccode\u003eSegmentation fault\u003c/code\u003e というエラーが表示される場合がある。\u003c/p\u003e\n\u003ch3\u003e原因\u003c/h3\u003e\n\u003cp\u003eIntel 製のチップを搭載した MacBook において、 Virtualization Framework というものが有効になっている際に起こる不具合です。\nこれは、 Docker Desktop v19.0.0 以上で発生が確認されています。\u003c/p\u003e\n\u003cp\u003e下記のサイトでこちらの不具合は把握されています。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/docker/for-mac/issues/6824\"\u003eDocker Desktop for mac での issue\u003c/a\u003e\u003c/p\u003e\n\u003ch3\u003e→解決方法\u003c/h3\u003e\n\u003cp\u003eファイル共有システムに利用している VirtioFS が Virtualization Framework を利用しています。\u003cbr\u003e\nですから、ファイル共有システムを他のものへと変更することで、原因である Virtualization Framework を無効化する必要があります。\u003c/p\u003e\n\u003cp\u003eそのために、Docker Desktop の設定を変更します。\u003c/p\u003e\n\u003cp\u003eまず、 Docker Desktop を開いてください。\u003c/p\u003e\n\u003cp\u003e開いたら、画像で示した右上にある、歯車マークをクリックしてください。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/faq/images/intro/how-to-set-grpc-1.png\" alt=\"Docker Desktop のホーム画面\"\u003e\u003c/p\u003e\n\u003cp\u003eクリックすると、以下のような設定画面が表示されます。\u003c/p\u003e\n\u003cp\u003e下の方へスクロールすると、画像で示したように、「Choose file sharing implementation for your containers」 と書かれた部分があります。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/faq/images/intro/how-to-set-grpc-2.png\" alt=\"Docker Desktop の設定画面\"\u003e\u003c/p\u003e\n\u003cp\u003eこれを以下の画像の指示に沿って、「gRPC FUSE」に変更してください。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/faq/images/intro/how-to-set-grpc-3.png\" alt=\"ファイル共有システムを gRPC FUSE に変更\"\u003e\u003c/p\u003e\n\u003cp\u003eすると、上の「Use Virtualization framework」 と書かれた部分のチェックを変更できるようになります。\u003cbr\u003e\nこのチェックを外すことで、「Virtualization framework」を無効化できます。\u003c/p\u003e\n\u003cp\u003e以下の画像を参考に、このチェックを外し、右下の「Apply \u0026#x26; restart」 をクリックしてください。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/faq/images/intro/how-to-set-grpc-4.png\" alt=\"Virtualization framework を無効化\"\u003e\u003c/p\u003e\n\u003cp\u003eこれによって Virtualization Framework を無効化でき、エラーが解消されるはずです。\u003c/p\u003e\n\u003cp\u003eなお、以前より Docker を利用した際の挙動が重くなる可能性があります。\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/[...slug]","query":{"slug":["intro","docker"]},"buildId":"F3Ge2EVgkAzlU4r2fKG0E","assetPrefix":"/faq","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>